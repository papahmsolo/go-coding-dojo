// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package query

import (
	"context"
	"database/sql"
	"time"
)

const createAccount = `-- name: CreateAccount :execresult
INSERT INTO bank.account (balance, status, opened)
VALUES (?, ?, ?)
`

type CreateAccountParams struct {
	Balance int32
	Status  AccountStatus
	Opened  time.Time
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createAccount, arg.Balance, arg.Status, arg.Opened)
}

const deductFromAccount = `-- name: DeductFromAccount :exec
UPDATE bank.account 
	SET balance = balance - ?
	WHERE balance > ? AND status = ? AND opened > ?
`

type DeductFromAccountParams struct {
	Balance   int32
	Balance_2 int32
	Status    AccountStatus
	Opened    time.Time
}

func (q *Queries) DeductFromAccount(ctx context.Context, arg DeductFromAccountParams) error {
	_, err := q.db.ExecContext(ctx, deductFromAccount,
		arg.Balance,
		arg.Balance_2,
		arg.Status,
		arg.Opened,
	)
	return err
}

const freezeAccounts = `-- name: FreezeAccounts :exec
UPDATE bank.account 
	SET status = "frozen"
	WHERE balance <= ? AND status = "regular"
`

func (q *Queries) FreezeAccounts(ctx context.Context, balance int32) error {
	_, err := q.db.ExecContext(ctx, freezeAccounts, balance)
	return err
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, balance, status, opened FROM bank.account WHERE status = ?
`

func (q *Queries) ListAccounts(ctx context.Context, status AccountStatus) ([]BankAccount, error) {
	rows, err := q.db.QueryContext(ctx, listAccounts, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BankAccount
	for rows.Next() {
		var i BankAccount
		if err := rows.Scan(
			&i.ID,
			&i.Balance,
			&i.Status,
			&i.Opened,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
